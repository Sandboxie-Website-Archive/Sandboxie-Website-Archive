<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-gb">
	<link rel="self" type="application/atom+xml" href="https://forums.sandboxie.com/phpBB3/app.php/feed/topic/9041" />

	<title>Sandboxie Support</title>
	<subtitle>Support Forum for Sandboxie</subtitle>
	<link href="https://forums.sandboxie.com/phpBB3/index.php" />
	<updated>2012-03-15T09:30:01-04:00</updated>

	<author><name><![CDATA[Sandboxie Support]]></name></author>
	<id>https://forums.sandboxie.com/phpBB3/app.php/feed/topic/9041</id>

		<entry>
		<author><name><![CDATA[Anonymous]]></name></author>
		<updated>2012-03-15T09:30:01-04:00</updated>

		<published>2012-03-15T09:30:01-04:00</published>
		<id>https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=78273#p78273</id>
		<link href="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=78273#p78273"/>
		<title type="html"><![CDATA[Updated version on CodeProject Deleted]]></title>

		
		<content type="html" xml:base="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=78273#p78273"><![CDATA[
Hi ddwyer, many thanks for your hard work!  Unfortunately, the updated version on CodeProject was deleted on 1 Nov 2010.  But not to worry, I've used your example and written a wrapper that loads Sandboxie dynamically (no more hard coded DllImport calls!).  Hope this helps, and thanks to Sandboxie for a really useful tool!<br><br>Phil<br><div class="codebox"><p>CODE: </p><pre><code>using System;using System.IO;using System.Linq;using System.Text;using System.Collections.Generic;using System.Runtime.InteropServices;namespace SandboxieWrapper{    public class SandboxPaths    {        public string FilePath;        public string KeyPath;        public string IpcPath;    }    public class ProcessInformation    {        public UInt32 ProcessId;        public string BoxName;        public string ImageName;        public string SidString;        public UInt32 SessionId;        public override string ToString()        {            try { return string.IsNullOrWhiteSpace(this.ImageName) ? base.ToString() : this.ImageName; }            catch { return base.ToString(); }        }    }    /// &lt;summary&gt;    /// Wrapper class to dynamically load Sandboxie dll (SbieDll.dll).  See http://www.sandboxie.com/index.php?SBIE_DLL_API    /// &lt;/summary&gt;    public class Sandboxie : IDisposable    {        private const string kernal32dll = "kernel32.dll";        [DllImport(kernal32dll)]        private static extern IntPtr LoadLibrary(string dllToLoad);        [DllImport(kernal32dll)]        private static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);        [DllImport(kernal32dll)]        private static extern bool FreeLibrary(IntPtr hModule);        /// &lt;summary&gt;        /// Enumerate Sandbox Names        /// &lt;/summary&gt;        /// &lt;param name="index"&gt;Specifies which sandbox to return. Initialize to -1. Sandboxes are enumerated in the order they appear in Sandboxie.ini.&lt;/param&gt;        /// &lt;param name="box_name"&gt;Receives the sandbox name&lt;/param&gt;        /// &lt;returns&gt;Returns the next value to use for the index parameter. Returns -1 when there is nothing left to enumerate.&lt;/returns&gt;        private delegate Int32 SbieApi_EnumBoxes(Int32 index, byte[] box_name);        /// &lt;summary&gt;        /// Query Sandbox Paths by Sandbox Name        /// &lt;/summary&gt;        /// &lt;param name="box_name"&gt;Specifies the name of the sandbox for which to return path information.&lt;/param&gt;        /// &lt;param name="file_path"&gt;Receives the path to the root directory of the sandbox, as set by the FileRootPath setting. The buffer receives at most the number of bytes specified by the file_path_len parameter.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="key_path"&gt;Receives the path to the root key of the sandbox registry, as set by the KeyRootPath setting. The buffer receives at most the number of bytes specified by the key_path_len parameter.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="ipc_path"&gt;Receives the path to the root object directory of the sandbox, as set by the IpcRootPath setting. The buffer receives at most the number of bytes specified by the ipc_path_len parameter.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="file_path_len"&gt;Specifies the length in bytes of the file_path buffer.  On return, receives the length in bytes needed to receive a complete buffer.&lt;/param&gt;        /// &lt;param name="key_path_len"&gt;Specifies the length in bytes of the key_path buffer.  On return, receives the length in bytes needed to receive a complete buffer.&lt;/param&gt;        /// &lt;param name="ipc_path_len"&gt;Specifies the length in bytes of the ipc_path buffer.  On return, receives the length in bytes needed to receive a complete buffer.&lt;/param&gt;        /// &lt;returns&gt;Returns zero on success, a non-zero value on error.&lt;/returns&gt;        private delegate Int32 SbieApi_QueryBoxPath(byte[] box_name, byte[] file_path, byte[] key_path, byte[] ipc_path,            ref ulong file_path_len, ref ulong key_path_len, ref ulong ipc_path_len);        /// &lt;summary&gt;        /// Query Sandbox Paths by Process ID        /// &lt;/summary&gt;        /// &lt;param name="process_id"&gt;Specifies the ID of the sandboxed process to query.&lt;/param&gt;        /// &lt;param name="file_path"&gt;Receives the path to the root directory of the sandbox, as set by the FileRootPath setting. The buffer receives at most the number of bytes specified by the file_path_len parameter.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="key_path"&gt;Receives the path to the root key of the sandbox registry, as set by the KeyRootPath setting. The buffer receives at most the number of bytes specified by the key_path_len parameter.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="ipc_path"&gt;Receives the path to the root object directory of the sandbox, as set by the IpcRootPath setting. The buffer receives at most the number of bytes specified by the ipc_path_len parameter.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="file_path_len"&gt;Specifies the length in bytes of the file_path buffer.  On return, receives the length in bytes needed to receive a complete buffer.&lt;/param&gt;        /// &lt;param name="key_path_len"&gt;Specifies the length in bytes of the key_path buffer.  On return, receives the length in bytes needed to receive a complete buffer.&lt;/param&gt;        /// &lt;param name="ipc_path_len"&gt;Specifies the length in bytes of the ipc_path buffer.  On return, receives the length in bytes needed to receive a complete buffer.&lt;/param&gt;        /// &lt;returns&gt;Returns zero on success, a non-zero value on error.&lt;/returns&gt;        private delegate Int32 SbieApi_QueryProcessPath(uint process_id, byte[] file_path, byte[] key_path, byte[] ipc_path,            ref ulong file_path_len, ref ulong key_path_len, ref ulong ipc_path_len);        /// &lt;summary&gt;        /// Enumerate Running Processes        /// &lt;/summary&gt;        /// &lt;param name="box_name"&gt;Specifies the name of the sandbox in which processes will be enumerated.&lt;/param&gt;        /// &lt;param name="all_sessions"&gt;Specifies TRUE to enumerate processes in all logon sessions or only in a particular logon session&lt;/param&gt;        /// &lt;param name="which_session"&gt;Specifies the logon session number in which processes will be enumerated.  Ignored if all_sessions if TRUE. Pass the value -1 to specify the current logon session.&lt;/param&gt;        /// &lt;param name="boxed_pids"&gt;Receives the process ID (PID) numbers. The first ULONG receives the number of processes enumerated. The second ULONG receives the first PID, the third ULONG receives the second PID, and so on.&lt;/param&gt;        /// &lt;returns&gt;Returns zero on success, a non-zero value on error.&lt;/returns&gt;        private delegate Int32 SbieApi_EnumProcessEx(byte[] box_name, bool all_sessions, Int32 which_session,            [MarshalAs(UnmanagedType.LPArray)] UInt32[] boxed_pids);        /// &lt;summary&gt;        /// Query Process Information        /// &lt;/summary&gt;        /// &lt;param name="process_id"&gt;Specifies the ID of the sandboxed process to query.&lt;/param&gt;        /// &lt;param name="box_name"&gt;Receives the name of the sandbox in which the process is running.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="image_name"&gt;Receives the process name.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="sid_string"&gt;Receives the SID string for the process.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;param name="session_id"&gt;Receives the logon session number in which the process is running.  Pass NULL to ignore this parameter.&lt;/param&gt;        /// &lt;returns&gt;Returns zero on success, a non-zero value on error.&lt;/returns&gt;        private delegate Int32 SbieApi_QueryProcess(uint process_id, byte[] box_name, byte[] image_name, byte[] sid_string, UIntPtr session_id);        /// &lt;summary&gt;        /// Terminate a Single Sandboxed Process        /// &lt;/summary&gt;        /// &lt;param name="process_id"&gt;Specifies the process ID for the sandboxed process that should be terminated.&lt;/param&gt;        /// &lt;returns&gt;Returns TRUE on success, FALSE on failure.  The target process is terminated by the Sandboxie service (SbieSvc) with exit code 1 through a call to the Windows API TerminateProcess (ProcessId, 1).&lt;/returns&gt;        private delegate bool SbieDll_KillOne(uint process_id);        /// &lt;summary&gt;        /// Terminate All Sandboxed Processes        /// &lt;/summary&gt;        /// &lt;param name="session_id"&gt;Specifies the logon session number in which sandboxed programs should be terminated.  Specify -1 to indicate the current logon session.&lt;/param&gt;        /// &lt;param name="box_name"&gt;Specifies the sandbox name in which sandboxed programs should be terminated.&lt;/param&gt;        /// &lt;returns&gt;Returns TRUE on success, FALSE on failure.  The target processes are terminated in the fashion described above; see SbieDll_KillOne.&lt;/returns&gt;        private delegate bool SbieDll_KillAll(Int32 session_id, byte[] box_name);        /// &lt;summary&gt;        /// Query Configuration from Sandboxie.ini        /// &lt;/summary&gt;        /// &lt;param name="section_name"&gt;Specifies the section name that contains the setting to query.&lt;/param&gt;        /// &lt;param name="setting_name"&gt;Specifies the setting name to query.&lt;/param&gt;        /// &lt;param name="setting_index"&gt;Specifies the zero-based index number for a setting that may appear multiple times.  The index number can be logically OR'ed with these special values: 0x40000000 - do not scan the [GlobalSettings] section if the specified setting name does appear in the specified section. 0x20000000 - do not expand any variables in the result.&lt;/param&gt;        /// &lt;param name="value"&gt;Receives the value of the specified setting.&lt;/param&gt;        /// &lt;param name="value_len"&gt;Specifies the maximum length in bytes of the buffer pointed to by the value parameter.&lt;/param&gt;        /// &lt;returns&gt;Returns zero on success.  Returns 0xC000008B if the setting was not found.  Any other return value indicates some other error.&lt;/returns&gt;        private delegate Int32 SbieApi_QueryConf(byte[] section_name, byte[] setting_name, UInt32 setting_index, byte[] value, UInt32 value_len);        /// &lt;summary&gt;        /// Reload Configuration from Sandboxie.ini        /// &lt;/summary&gt;        /// &lt;param name="session_id"&gt;Specifies the logon session number to which Sandboxie will log any error messages.  Pass -1 for the current logon session.&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        private delegate Int32 SbieApi_ReloadConf(Int32 session_id);        //TODO: SbieDll_Hook        //TODO: DllCallback        private bool disposed = false;        private IntPtr dllPtr = IntPtr.Zero;        public Sandboxie() : this(@"C:\Program Files\Sandboxie\SbieDll.dll")        {        }        public Sandboxie(string sbieDllPath)        {            if (string.IsNullOrWhiteSpace(sbieDllPath))                throw new ArgumentNullException("sbieDllPath");            if (!File.Exists(sbieDllPath))                throw new FileNotFoundException("Supplied SbieDll.dll not found", sbieDllPath);            this.dllPtr = LoadLibrary(sbieDllPath);            if (this.dllPtr == IntPtr.Zero)                throw new FileLoadException("Unable to load supplied SbieDll.dll", sbieDllPath);        }        ~Sandboxie()        {            this.Dispose(false);        }        public virtual void Dispose()        {            this.Dispose(true);            GC.SuppressFinalize(this);        }        /// &lt;summary&gt;        /// Enumerate Sandbox Names        /// &lt;/summary&gt;        /// &lt;returns&gt;An array of sandbox names&lt;/returns&gt;        public string[] EnumBoxes()        {            SbieApi_EnumBoxes extMethod = (SbieApi_EnumBoxes)this.GetExternalMethodDelegate&lt;SbieApi_EnumBoxes&gt;();            List&lt;string&gt; result = new List&lt;string&gt;();            Int32 index = -1;            while (true)            {                byte[] sandboxNameBytes = new byte[34];                index = extMethod(index, sandboxNameBytes);                if (index == -1)                    break;                string sandboxName = ConvertFromWChar(sandboxNameBytes);                result.Add(sandboxName);            }            return result.ToArray();        }        /// &lt;summary&gt;        /// Query Sandbox Paths by Sandbox Name        /// &lt;/summary&gt;        /// &lt;param name="box_name"&gt;The name of the sandbox for which to return path information.&lt;/param&gt;        /// &lt;returns&gt;A &lt;see cref="SandboxPaths"/&gt; for the supplied &lt;paramref name="box_name"/&gt;&lt;/returns&gt;        /// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when &lt;paramref name="box_name"/&gt; is null or empty&lt;/exception&gt;        /// &lt;exception cref="System.ApplicationException"&gt;Thrown when &lt;see cref="SbieApi_QueryBoxPath"/&gt; returns non-zero&lt;/exception&gt;        public SandboxPaths QueryBoxPath(string box_name)        {            if (string.IsNullOrWhiteSpace(box_name))                throw new ArgumentNullException("box_name");            SbieApi_QueryBoxPath extMethod = (SbieApi_QueryBoxPath)this.GetExternalMethodDelegate&lt;SbieApi_QueryBoxPath&gt;();            ulong file_path_len = 0;            ulong key_path_len = 0;            ulong ipc_path_len = 0;            byte[] box_name_bytes = Encoding.Unicode.GetBytes(box_name);            Int32 methodResult = extMethod(box_name_bytes, null, null, null, ref file_path_len, ref key_path_len, ref ipc_path_len);            if (methodResult != 0)                throw new ApplicationException(extMethod.GetType().Name + " returned " + methodResult.ToString());            byte[] file_path = new byte[file_path_len];            byte[] key_path = new byte[key_path_len];            byte[] ipc_path = new byte[ipc_path_len];            methodResult = extMethod(box_name_bytes, file_path, key_path, ipc_path, ref file_path_len, ref key_path_len, ref ipc_path_len);            if (methodResult != 0)                throw new ApplicationException(extMethod.GetType().Name + " returned " + methodResult.ToString());            string filePath = ConvertFromWChar(file_path);            string keyPath = ConvertFromWChar(key_path);            string ipcPath = ConvertFromWChar(ipc_path);            return new SandboxPaths() { FilePath = filePath, KeyPath = keyPath, IpcPath = ipcPath };        }        /// &lt;summary&gt;        /// Query Sandbox Paths by Process ID        /// &lt;/summary&gt;        /// &lt;param name="process_id"&gt;Specifies the ID of the sandboxed process to query.&lt;/param&gt;        /// &lt;returns&gt;A &lt;see cref="SandboxPaths"/&gt; for the supplied &lt;paramref name="process_id"/&gt;&lt;/returns&gt;        /// &lt;exception cref="System.ApplicationException"&gt;Thrown when &lt;see cref="SbieApi_QueryProcessPath"/&gt; returns non-zero&lt;/exception&gt;        public SandboxPaths QueryProcessPath(uint process_id)        {            SbieApi_QueryProcessPath extMethod = (SbieApi_QueryProcessPath)this.GetExternalMethodDelegate&lt;SbieApi_QueryProcessPath&gt;();            ulong file_path_len = 0;            ulong key_path_len = 0;            ulong ipc_path_len = 0;            Int32 methodResult = extMethod(process_id, null, null, null, ref file_path_len, ref key_path_len, ref ipc_path_len);            if (methodResult != 0)                throw new ApplicationException(extMethod.GetType().Name + " returned " + methodResult.ToString());            byte[] file_path = new byte[file_path_len];            byte[] key_path = new byte[key_path_len];            byte[] ipc_path = new byte[ipc_path_len];            methodResult = extMethod(process_id, file_path, key_path, ipc_path, ref file_path_len, ref key_path_len, ref ipc_path_len);            if (methodResult != 0)                throw new ApplicationException(extMethod.GetType().Name + " returned " + methodResult.ToString());            string filePath = ConvertFromWChar(file_path);            string keyPath = ConvertFromWChar(key_path);            string ipcPath = ConvertFromWChar(ipc_path);            return new SandboxPaths() { FilePath = filePath, KeyPath = keyPath, IpcPath = ipcPath };        }        /// &lt;summary&gt;        /// Enumerate Running Processes        /// &lt;/summary&gt;        /// &lt;param name="box_name"&gt;Specifies the name of the sandbox in which processes will be enumerated.&lt;/param&gt;        /// &lt;param name="all_sessions"&gt;Specifies TRUE to enumerate processes in all logon sessions or only in a particular logon session&lt;/param&gt;        /// &lt;param name="which_session"&gt;Specifies the logon session number in which processes will be enumerated.  Ignored if all_sessions if TRUE. Pass the value -1 to specify the current logon session.&lt;/param&gt;        /// &lt;returns&gt;An array of process ID's for the supplied &lt;paramref name="box_name"/&gt;&lt;/returns&gt;        /// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when &lt;paramref name="box_name"/&gt; is null or empty&lt;/exception&gt;        public UInt32[] EnumProcess(string box_name, bool all_sessions = true, Int32 which_session = -1)        {            if (string.IsNullOrWhiteSpace(box_name))                throw new ArgumentNullException("box_name");            SbieApi_EnumProcessEx extMethod = (SbieApi_EnumProcessEx)this.GetExternalMethodDelegate&lt;SbieApi_EnumProcessEx&gt;();            byte[] box_name_bytes = Encoding.Unicode.GetBytes(box_name);            UInt32[] boxed_pids = new UInt32[512];            Int32 methodResult = extMethod(box_name_bytes, all_sessions, which_session, boxed_pids);            if (methodResult != 0)                throw new ApplicationException(extMethod.GetType().Name + " returned " + methodResult.ToString());            List&lt;UInt32&gt; result = new List&lt;UInt32&gt;();            for (int loop = 1; loop &lt;= boxed_pids[0]; loop++)            {                if (boxed_pids[0] &gt; 0)                    result.Add(boxed_pids[loop]);            }            return result.ToArray();        }        /// &lt;summary&gt;        /// Query Process Information        /// &lt;/summary&gt;        /// &lt;param name="process_id"&gt;Specifies the ID of the sandboxed process to query.&lt;/param&gt;        /// &lt;returns&gt;A &lt;see cref="ProcessInformation"/&gt; for the supplied &lt;paramref name="process_id"/&gt;&lt;/returns&gt;        /// &lt;exception cref="System.ApplicationException"&gt;Thrown when &lt;see cref="SbieApi_QueryProcess"/&gt; returns non-zero&lt;/exception&gt;        public ProcessInformation QueryProcess(uint process_id)        {            SbieApi_QueryProcess extMethod = (SbieApi_QueryProcess)this.GetExternalMethodDelegate&lt;SbieApi_QueryProcess&gt;();            byte[] box_name_bytes = new byte[34];            byte[] image_name_bytes = new byte[96];            byte[] sid_string_bytes = new byte[96];            UIntPtr session_id = new UIntPtr();            Int32 methodResult = extMethod(process_id, box_name_bytes, image_name_bytes, sid_string_bytes, session_id);            if (methodResult != 0)                throw new ApplicationException(extMethod.GetType().Name + " returned " + methodResult.ToString());            string box_name = this.ConvertFromWChar(box_name_bytes);            string image_name = this.ConvertFromWChar(image_name_bytes);            string sid_string = this.ConvertFromWChar(sid_string_bytes);            return new ProcessInformation()            {                ProcessId = process_id,                BoxName = box_name,                ImageName = image_name,                SidString = sid_string,                SessionId = session_id.ToUInt32()            };        }        /// &lt;summary&gt;        /// Terminate a Single Sandboxed Process        /// &lt;/summary&gt;        /// &lt;remarks&gt;        /// When run against version 3.58, fails with "SBIE2203 Failed to communicate with Sandboxie Service:  connect C0000041"        /// See http://www.sandboxie.com/index.php?SBIE2203        /// &lt;/remarks&gt;        /// &lt;param name="process_id"&gt;Specifies the process ID for the sandboxed process that should be terminated.&lt;/param&gt;        /// &lt;returns&gt;Returns TRUE on success, FALSE on failure.  The target process is terminated by the Sandboxie service (SbieSvc) with exit code 1 through a call to the Windows API TerminateProcess (&lt;paramref name="process_id"/&gt;, 1).&lt;/returns&gt;        public bool KillOne(uint process_id)        {            SbieDll_KillOne extMethod = (SbieDll_KillOne)this.GetExternalMethodDelegate&lt;SbieDll_KillOne&gt;();            return extMethod(process_id);        }        /// &lt;summary&gt;        /// Terminate All Sandboxed Processes        /// &lt;/summary&gt;        /// &lt;param name="box_name"&gt;Specifies the sandbox name in which sandboxed programs should be terminated.&lt;/param&gt;        /// &lt;returns&gt;Returns TRUE on success, FALSE on failure.  The target processes are terminated in the fashion described above; see KillOne.&lt;/returns&gt;        /// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when &lt;paramref name="box_name"/&gt; is null or empty&lt;/exception&gt;        public bool KillAll(string box_name)        {            return this.KillAll(-1, box_name);        }        /// &lt;summary&gt;        /// Terminate All Sandboxed Processes        /// &lt;/summary&gt;        /// &lt;param name="session_id"&gt;Specifies the logon session number in which sandboxed programs should be terminated.  Specify -1 to indicate the current logon session.&lt;/param&gt;        /// &lt;param name="box_name"&gt;Specifies the sandbox name in which sandboxed programs should be terminated.&lt;/param&gt;        /// &lt;returns&gt;Returns TRUE on success, FALSE on failure.  The target processes are terminated in the fashion described above; see KillOne.&lt;/returns&gt;        /// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when &lt;paramref name="box_name"/&gt; is null or empty&lt;/exception&gt;        public bool KillAll(Int32 session_id, string box_name)        {            if (string.IsNullOrWhiteSpace(box_name))                throw new ArgumentNullException("box_name");            SbieDll_KillAll extMethod = (SbieDll_KillAll)this.GetExternalMethodDelegate&lt;SbieDll_KillAll&gt;();            byte[] box_name_bytes = Encoding.Unicode.GetBytes(box_name);            return extMethod(session_id, box_name_bytes);        }        /// &lt;summary&gt;        /// Query Configuration from Sandboxie.ini        /// &lt;/summary&gt;        /// &lt;param name="section_name"&gt;Specifies the section name that contains the setting to query.&lt;/param&gt;        /// &lt;param name="setting_name"&gt;Specifies the setting name to query.&lt;/param&gt;        /// &lt;param name="setting_index"&gt;Specifies the zero-based index number for a setting that may appear multiple times.  The index number can be logically OR'ed with these special values: 0x40000000 - do not scan the [GlobalSettings] section if the specified setting name does appear in the specified section. 0x20000000 - do not expand any variables in the result.&lt;/param&gt;        /// &lt;returns&gt;Returns zero on success.  Returns 0xC000008B if the setting was not found.  Any other return value indicates some other error.&lt;/returns&gt;        /// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when &lt;paramref name="section_name"/&gt; is null or empty&lt;/exception&gt;        /// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when &lt;paramref name="setting_name"/&gt; is null or empty&lt;/exception&gt;        /// &lt;exception cref="System.ApplicationException"&gt;Thrown when &lt;see cref="SbieApi_QueryConf"/&gt; returns non-zero&lt;/exception&gt;        public string QueryConf(string section_name, string setting_name, UInt32 setting_index = 0)        {            if (string.IsNullOrWhiteSpace(section_name))                throw new ArgumentNullException("section_name");            if (string.IsNullOrWhiteSpace(setting_name))                throw new ArgumentNullException("setting_name");            SbieApi_QueryConf extMethod = (SbieApi_QueryConf)this.GetExternalMethodDelegate&lt;SbieApi_QueryConf&gt;();            byte[] section_name_bytes = Encoding.Unicode.GetBytes(section_name);            byte[] setting_name_bytes = Encoding.Unicode.GetBytes(setting_name);            byte[] value = new byte[8000];            Int32 methodResult = extMethod(section_name_bytes, setting_name_bytes, setting_index, value, (UInt32)value.Length);            if (methodResult != 0)                throw new ApplicationException(extMethod.GetType().Name + " returned " + methodResult.ToString());            return this.ConvertFromWChar(value);        }        /// &lt;summary&gt;        /// Reload Configuration from Sandboxie.ini        /// &lt;/summary&gt;        /// &lt;param name="session_id"&gt;Specifies the logon session number to which Sandboxie will log any error messages.  Pass -1 for the current logon session.&lt;/param&gt;        public void ReloadConf(Int32 session_id = -1)        {            SbieApi_ReloadConf extMethod = (SbieApi_ReloadConf)this.GetExternalMethodDelegate&lt;SbieApi_ReloadConf&gt;();            Int32 methodResult = extMethod(session_id);            if (methodResult != 0)                throw new ApplicationException(extMethod.GetType().Name + " returned " + methodResult.ToString());        }        /// &lt;summary&gt;        /// Enumerate Running Query Process Information        /// &lt;/summary&gt;        /// &lt;param name="box_name"&gt;Specifies the name of the sandbox in which processes will be enumerated.&lt;/param&gt;        /// &lt;param name="all_sessions"&gt;Specifies TRUE to enumerate processes in all logon sessions or only in a particular logon session&lt;/param&gt;        /// &lt;param name="which_session"&gt;Specifies the logon session number in which processes will be enumerated.  Ignored if all_sessions if TRUE. Pass the value -1 to specify the current logon session.&lt;/param&gt;        /// &lt;returns&gt;An array of &lt;see cref="ProcessInformation"/&gt; for the supplied &lt;paramref name="box_name"/&gt;&lt;/returns&gt;        /// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when &lt;paramref name="box_name"/&gt; is null or empty&lt;/exception&gt;        public ProcessInformation[] QueryEnumProcess(string box_name, bool all_sessions = true, Int32 which_session = -1)        {            if (string.IsNullOrWhiteSpace(box_name))                throw new ArgumentNullException("box_name");            UInt32[] pids = this.EnumProcess(box_name, all_sessions, which_session);            return pids.Select(pid =&gt; this.QueryProcess(pid)).ToArray();        }        /// &lt;summary&gt;        /// Returns true if the sandbox is idle (has no running processes)        /// &lt;/summary&gt;        /// &lt;param name="box_name"&gt;Specifies the name of the sandbox in which to check for running processes.&lt;/param&gt;        /// &lt;returns&gt;Returns true if the sandbox specified in &lt;paramref name="box_name"/&gt; has no running processes.&lt;/returns&gt;        /// &lt;exception cref="System.ArgumentNullException"&gt;Thrown when &lt;paramref name="box_name"/&gt; is null or empty&lt;/exception&gt;        public bool BoxIsIdle(string box_name)        {            if (string.IsNullOrWhiteSpace(box_name))                throw new ArgumentNullException("box_name");            return this.EnumProcess(box_name).Length == 0;        }        /// &lt;summary&gt;        /// Returns true if the sandbox is idle (has running processes)        /// &lt;/summary&gt;        /// &lt;param name="box_name"&gt;Specifies the name of the sandbox in which to check for running processes.&lt;/param&gt;        /// &lt;returns&gt;Returns true if the sandbox specified in &lt;paramref name="box_name"/&gt; has running processes.&lt;/returns&gt;        public bool BoxIsBusy(string box_name)        {            return !this.BoxIsIdle(box_name);        }        /// &lt;summary&gt;        /// Enumerate Idle Sandbox Names        /// &lt;/summary&gt;        /// &lt;returns&gt;An array of sandbox names that are idle&lt;/returns&gt;        public string[] EnumIdleBoxes()        {            return this.EnumBoxes().Where(box =&gt; this.BoxIsIdle(box)).ToArray();        }        private void Dispose(bool disposing)        {            if (!this.disposed)            {                try                {                    if (disposing)                    {                        if (this.dllPtr != IntPtr.Zero)                            FreeLibrary(this.dllPtr);                        this.dllPtr = IntPtr.Zero;                    }                }                finally { this.disposed = true; }            }        }        private Delegate GetExternalMethodDelegate&lt;T&gt;()        {            Type type = typeof(T);            IntPtr funcAddr = GetProcAddress(this.dllPtr, type.Name);            if (funcAddr == IntPtr.Zero)                throw new ApplicationException(string.Format("External method '{0}' not found", type.Name));            return Marshal.GetDelegateForFunctionPointer(funcAddr, type);        }        private string ConvertFromWChar(byte[] stringBytes)        {            string result = Encoding.Unicode.GetString(stringBytes);            int idx = result.IndexOf("\0");            if (idx != -1)                result = result.Remove(idx);            return result;        }    }}</code></pre></div><p>Statistics: Posted by Guest — Thu Mar 15, 2012 9:30 am</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[ddwyer]]></name></author>
		<updated>2010-10-27T19:07:47-04:00</updated>

		<published>2010-10-27T19:07:47-04:00</published>
		<id>https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=60102#p60102</id>
		<link href="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=60102#p60102"/>
		<title type="html"><![CDATA[Update and Article Now Available]]></title>

		
		<content type="html" xml:base="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=60102#p60102"><![CDATA[
Updated version and article posted to CodeProject<br><a href="http://www.codeproject.com/KB/winsdk/SandboxieWrapper.aspx" class="postlink">http://www.codeproject.com/KB/winsdk/Sa ... apper.aspx</a><p>Statistics: Posted by <a href="https://forums.sandboxie.com/phpBB3/memberlist.php?mode=viewprofile&amp;u=4871">ddwyer</a> — Wed Oct 27, 2010 7:07 pm</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[The Martian]]></name></author>
		<updated>2010-10-02T08:05:04-04:00</updated>

		<published>2010-10-02T08:05:04-04:00</published>
		<id>https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58977#p58977</id>
		<link href="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58977#p58977"/>
		<title type="html"><![CDATA[Re: .NET Wrapper]]></title>

		
		<content type="html" xml:base="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58977#p58977"><![CDATA[
<blockquote><div><cite>ddwyer wrote:</cite>Hello all,<br>I have enjoyed using Sandboxie, and wished I had found it sooner. My usage is as an RDP replacement for running browser sessions. The US$50 it costs is simply amazing when you compare to the US$35k Microsoft wanted and US$20k Graphon GoGlobal costs to do much of our used functionality.<br><br>Anyway, here is source for a C# wrapper of the SBIE API, free to use, distribute, and modify as you see fit. I would prefer to know if you improve upon it (not hard to do), because I'll be posting this same code on CodeProject.com to sing the praises of Sandboxie soon.<br></div></blockquote>Hello Mr. ddwyer, much appreciate the code. A nice little starter pack for anyone (such as my-self) wishing to try their luck and Dev an app or two for use with Sandboxie.<br><br>Also, building on what you said "prefer to know if you improve upon it"; not sure of the chance of me improving on it as yet, but would definitely be interested in seeing any improvements or changes which you might be coming up with too. Thanks once again.<p>Statistics: Posted by <a href="https://forums.sandboxie.com/phpBB3/memberlist.php?mode=viewprofile&amp;u=4818">The Martian</a> — Sat Oct 02, 2010 8:05 am</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[tzuk]]></name></author>
		<updated>2010-09-29T18:01:31-04:00</updated>

		<published>2010-09-29T18:01:31-04:00</published>
		<id>https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58860#p58860</id>
		<link href="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58860#p58860"/>
		<title type="html"><![CDATA[.NET Wrapper]]></title>

		
		<content type="html" xml:base="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58860#p58860"><![CDATA[
I see.  So keep in mind that in some scenarios, SbieDll is called something else.  For instance, in 32-bit programs on 64-bit Windows, SbieDll is called SbieDllX.<p>Statistics: Posted by <a href="https://forums.sandboxie.com/phpBB3/memberlist.php?mode=viewprofile&amp;u=3">tzuk</a> — Wed Sep 29, 2010 6:01 pm</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[ddwyer]]></name></author>
		<updated>2010-09-29T09:50:58-04:00</updated>

		<published>2010-09-29T09:50:58-04:00</published>
		<id>https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58852#p58852</id>
		<link href="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58852#p58852"/>
		<title type="html"><![CDATA[.NET Wrapper]]></title>

		
		<content type="html" xml:base="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58852#p58852"><![CDATA[
With static linking, no. With dynamic, you can, but it becomes a little more onerous to write the wrapper. All those attributes are annoying to specify in a variety of properties and methods.<p>Statistics: Posted by <a href="https://forums.sandboxie.com/phpBB3/memberlist.php?mode=viewprofile&amp;u=4871">ddwyer</a> — Wed Sep 29, 2010 9:50 am</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[tzuk]]></name></author>
		<updated>2010-09-29T03:47:29-04:00</updated>

		<published>2010-09-29T03:47:29-04:00</published>
		<id>https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58837#p58837</id>
		<link href="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58837#p58837"/>
		<title type="html"><![CDATA[.NET Wrapper]]></title>

		
		<content type="html" xml:base="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58837#p58837"><![CDATA[
That look very nice.  But one minor point, is it possible for such .NET imports to not be tied to a specific DLL name?<p>Statistics: Posted by <a href="https://forums.sandboxie.com/phpBB3/memberlist.php?mode=viewprofile&amp;u=3">tzuk</a> — Wed Sep 29, 2010 3:47 am</p><hr />
]]></content>
	</entry>
		<entry>
		<author><name><![CDATA[ddwyer]]></name></author>
		<updated>2010-09-28T23:22:12-04:00</updated>

		<published>2010-09-28T23:22:12-04:00</published>
		<id>https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58829#p58829</id>
		<link href="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58829#p58829"/>
		<title type="html"><![CDATA[.NET Wrapper]]></title>

		
		<content type="html" xml:base="https://forums.sandboxie.com/phpBB3/viewtopic.php?t=9041&amp;p=58829#p58829"><![CDATA[
Hello all,<br>I have enjoyed using Sandboxie, and wished I had found it sooner. My usage is as an RDP replacement for running browser sessions. The US$50 it costs is simply amazing when you compare to the US$35k Microsoft wanted and US$20k Graphon GoGlobal costs to do much of our used functionality.<br><br>Anyway, here is source for a C# wrapper of the SBIE API, free to use, distribute, and modify as you see fit. I would prefer to know if you improve upon it (not hard to do), because I'll be posting this same code on CodeProject.com to sing the praises of Sandboxie soon.<br><div class="codebox"><p>CODE: </p><pre><code>using System;using System.Collections.Generic;using System.Runtime.InteropServices;using System.Text;namespace SandboxieWrapper{    public class SandboxieNative    {        private static string ConvertFromWChar(byte[] incoming)        {            string outgoing = Encoding.Unicode.GetString(incoming);            outgoing = outgoing.Remove(outgoing.IndexOf("\0"));            return outgoing;        }        [DllImport("SbieDll.dll")]        private static extern int SbieApi_EnumBoxes(            int index,            byte[] boxname);        /// &lt;summary&gt;        /// Retrieves the names of the sandboxes        /// &lt;/summary&gt;        /// &lt;returns&gt;list of sandboxes as string&lt;/returns&gt;        public List&lt;string&gt; EnumerateSandboxes()        {            var sandboxes = new List&lt;string&gt;();                       int index = -1;            while (true)            {                var name = new byte[34];                index = SbieApi_EnumBoxes(index, name);                if (index == -1) break;                string sandboxname = ConvertFromWChar(name);                sandboxes.Add(sandboxname);            }            return sandboxes;        }        public struct SandboxPaths        {            public string FilePath;            public string KeyPath;            public string IpcPath;        }        [DllImport("SbieDll.dll")]        private static extern int SbieApi_QueryBoxPath(byte[] boxname,                byte[] filepath,                byte[] keypath,                byte[] ipcpath,                ref ulong filepathlen,                ref ulong keypathlen,                ref ulong ipcpathlen);        /// &lt;summary&gt;        /// Retrieves path information for a sandbox        /// &lt;/summary&gt;        /// &lt;param name="boxname"&gt;name of the sandbox&lt;/param&gt;        /// &lt;returns&gt;SandboxPaths struct&lt;/returns&gt;        public SandboxPaths QueryPaths(string boxname)        {            ulong fileLen = 0;            ulong keyLen = 0;            ulong ipcLen = 0;            byte[] byteBoxName = Encoding.Unicode.GetBytes(boxname);            SbieApi_QueryBoxPath(byteBoxName, null, null, null, ref fileLen, ref keyLen, ref ipcLen);                        var fileBuf = new byte[fileLen];            var keyBuf = new byte[keyLen];            var ipcBuf = new byte[ipcLen];            SbieApi_QueryBoxPath(byteBoxName, fileBuf, keyBuf, ipcBuf, ref fileLen, ref keyLen, ref ipcLen);            var paths = new SandboxPaths                            {                                FilePath = ConvertFromWChar(fileBuf),                                KeyPath = ConvertFromWChar(keyBuf),                                IpcPath = ConvertFromWChar(ipcBuf)                            };            return paths;        }        [DllImport("SbieDll.dll")]        private static extern int SbieApi_QueryProcessPath(uint processid,                byte[] filepath,                byte[] keypath,                byte[] ipcpath,                ref ulong filepathlen,                ref ulong keypathlen,                ref ulong ipcpathlen);        /// &lt;summary&gt;        /// Retrieves path information for a sandbox        /// &lt;/summary&gt;        /// &lt;param name="processid"&gt;process id within a sandbox&lt;/param&gt;        /// &lt;returns&gt;SandboxPaths struct&lt;/returns&gt;        public SandboxPaths QueryPaths(uint processid)        {            ulong fileLen = 0;            ulong keyLen = 0;            ulong ipcLen = 0;            SbieApi_QueryProcessPath(processid, null, null, null, ref fileLen, ref keyLen, ref ipcLen);            var fileBuf = new byte[fileLen];            var keyBuf = new byte[keyLen];            var ipcBuf = new byte[ipcLen];            SbieApi_QueryProcessPath(processid, fileBuf, keyBuf, ipcBuf, ref fileLen, ref keyLen, ref ipcLen);            var paths = new SandboxPaths            {                FilePath = ConvertFromWChar(fileBuf),                KeyPath = ConvertFromWChar(keyBuf),                IpcPath = ConvertFromWChar(ipcBuf)            };            return paths;        }        [DllImport("SbieDll.dll")]        private static extern int SbieApi_EnumProcessEx(                byte[] boxname,                bool allsessions,                Int32 whichsession,                [MarshalAs(UnmanagedType.LPArray)]                 UInt32[] boxedpids);        /// &lt;summary&gt;        /// Retrieve a list of processes for a sandbox        /// &lt;/summary&gt;        /// &lt;param name="boxname"&gt;name of the sandbox&lt;/param&gt;        /// &lt;param name="allsessions"&gt;flag indicating all sessions (true) or a specific session (false)&lt;/param&gt;        /// &lt;param name="whichsession"&gt;if allessions is false, this indicates the specific session&lt;/param&gt;        /// &lt;returns&gt;list of process ids for the sandbox&lt;/returns&gt;        public List&lt;UInt32&gt; EnumerateProcesses(string boxname, bool allsessions, Int32 whichsession)        {            var pids = new UInt32[512];            byte[] byteBoxName = Encoding.Unicode.GetBytes(boxname);            SbieApi_EnumProcessEx(byteBoxName, allsessions, whichsession, pids);            // first item contains count            var pidlist = new List&lt;UInt32&gt;();            for (int i = 1; i &lt;= pids[0]; i++)            {                if (pids[i] &gt; 0) pidlist.Add(pids[i]);            }            return pidlist;        }        /// &lt;summary&gt;        /// Retrieves process information for all processes in a sandbox        /// &lt;/summary&gt;        /// &lt;param name="boxname"&gt;name of the sandbox&lt;/param&gt;        /// &lt;returns&gt;list of ProcessInformation struct&lt;/returns&gt;        public List&lt;ProcessInformation&gt; EnumerateProcesses(string boxname)        {            List&lt;UInt32&gt; pidlist = EnumerateProcesses(boxname,true,-1);            var proclist = new List&lt;ProcessInformation&gt;();            foreach (uint pid in pidlist)            {                proclist.Add(GetProcessInfo(pid));            }            return proclist;        }        [DllImport("SbieDll.dll")]        private static extern int SbieApi_QueryProcess(                uint processid,                byte[] boxname,            // pointer to WCHAR [34]                byte[] imagename,          // pointer to WCHAR [96]                byte[] sidstring,          // pointer to WCHAR [96]                UIntPtr sessionid);        public struct ProcessInformation        {            public UInt32 ProcessId;            public string BoxName;            public string Imagename;            public string SidString;            public UInt32 SessionId;        }        /// &lt;summary&gt;        /// retrieve information about a single process        /// &lt;/summary&gt;        /// &lt;param name="processid"&gt;process id to retrieve&lt;/param&gt;        /// &lt;returns&gt;ProcessInformation struct&lt;/returns&gt;        public ProcessInformation GetProcessInfo(uint processid)        {            var proc = new ProcessInformation();            var boxname = new byte[34];            var imagename = new byte[96];            var sidstring = new byte[96];            var sessionid = new UIntPtr();            SbieApi_QueryProcess(processid, boxname, imagename, sidstring, sessionid);            proc.ProcessId = processid;            proc.BoxName = ConvertFromWChar(boxname);            proc.Imagename = ConvertFromWChar(imagename);            proc.SidString = ConvertFromWChar(sidstring);            proc.SessionId = sessionid.ToUInt32();            return proc;        }        [DllImport("SbieDll.dll")]        private static extern bool SbieDll_KillOne(ulong processid);        /// &lt;summary&gt;        /// terminates a single process        /// &lt;/summary&gt;        /// &lt;param name="processid"&gt;process id to terminate&lt;/param&gt;        /// &lt;returns&gt;true on success&lt;/returns&gt;        public bool TerminateProcess(UInt32 processid)        {            return SbieDll_KillOne(processid);        }        [DllImport("SbieDll.dll")]        private static extern bool SbieDll_KillAll(Int32 sessionid, byte[] boxname);        /// &lt;summary&gt;        /// terminates all processes in a sandbox        /// &lt;/summary&gt;        /// &lt;param name="boxname"&gt;name of the sandbox&lt;/param&gt;        /// &lt;param name="sessionid"&gt;session id (default -1)&lt;/param&gt;        /// &lt;returns&gt;true on success&lt;/returns&gt;        public bool TerminateAllProcesses(string boxname, int sessionid=-1)        {            byte[] byteBoxName = Encoding.Unicode.GetBytes(boxname);            return SbieDll_KillAll(sessionid, byteBoxName);        }        [DllImport("SbieDll.dll")]        private static extern Int32 SbieApi_QueryConf(            byte[] sectionname, // pointer to WCHAR [34]            byte[] settingname, // pointer to WCHAR [66]            UInt32 settingindex,            byte[] value,            UInt32 valuelen);        /// &lt;summary&gt;        /// Requests configuration information        /// &lt;/summary&gt;        /// &lt;param name="sectionName"&gt;section to retrieve&lt;/param&gt;        /// &lt;param name="settingName"&gt;setting to retrieve&lt;/param&gt;        /// &lt;param name="settingindex"&gt;if more than 1, the 0-based index to retrieve (default is zero)&lt;/param&gt;        /// &lt;returns&gt;value as string&lt;/returns&gt;        public string QueryConfiguration(string sectionName, string settingName, int settingindex=0)        {            byte[] byteSectionName = Encoding.Unicode.GetBytes(sectionName);            byte[] byteSettingName = Encoding.Unicode.GetBytes(settingName);            const uint valuelen = 8000;            var valueBuf = new byte[valuelen];            SbieApi_QueryConf(byteSectionName, byteSettingName, (UInt32)settingindex, valueBuf, valuelen);            return ConvertFromWChar(valueBuf);        }        [DllImport("SbieDll.dll")]        private static extern UInt32 SbieApi_ReloadConf(UInt32 sessionid);        /// &lt;summary&gt;        /// Causes the configuration file to be reloaded        /// &lt;/summary&gt;        /// &lt;param name="sessionid"&gt;session to reload it for or -1 for all&lt;/param&gt;        /// &lt;returns&gt;zero on success, a non-zero value on error&lt;/returns&gt;        public UInt32 ReloadConfiguration(int sessionid=-1)        {            return SbieApi_ReloadConf((UInt32)sessionid);        }               [DllImport("SbieDll.dll")]        private static extern void SbieDll_Hook(char[] name, Delegate sourcefunc, Delegate detourfunc);        /// &lt;summary&gt;        /// UNTESTED METHOD to set a hook        /// &lt;/summary&gt;        /// &lt;param name="hookName"&gt;name of the hook to set&lt;/param&gt;        /// &lt;param name="sourcefunction"&gt;delegate to override&lt;/param&gt;        /// &lt;param name="detourfunction"&gt;delegate to detour toward&lt;/param&gt;        public void SetHook(string hookName, Delegate sourcefunction, Delegate detourfunction)        {            SbieDll_Hook(hookName.ToCharArray(), sourcefunction, detourfunction);        }            }}</code></pre></div><p>Statistics: Posted by <a href="https://forums.sandboxie.com/phpBB3/memberlist.php?mode=viewprofile&amp;u=4871">ddwyer</a> — Tue Sep 28, 2010 11:22 pm</p><hr />
]]></content>
	</entry>
	</feed>
